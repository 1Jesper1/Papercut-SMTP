/*  
 * Papercut
 *
 *  Copyright © 2008 - 2012 Ken Robertson
 *  Copyright © 2013 - 2014 Jaben Cargman
 *  
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *  
 *  http://www.apache.org/licenses/LICENSE-2.0
 *  
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  
 */

namespace Papercut.Service
{
    #region Using

    using System;
    using System.Collections.Generic;
    using System.Diagnostics;
    using System.Linq;
    using System.Net;
    using System.Net.Sockets;
    using System.Threading;

    using Papercut.Core;

    #endregion

    public class Server : IServer
    {
        #region Fields

        readonly Dictionary<int, IConnection> _connections = new Dictionary<int, IConnection>();

        IPAddress _address;

        int _connectionID;

        bool _isReady;

        bool _isRunning;

        bool _isStarting;

        Socket _listener;

        int _port;

        Thread _timeoutThread;

        #endregion

        #region Public Methods and Operators

        public int DefaultPort
        {
            get
            {
                return 25;
            }
        }

        public void Listen(string ip, int port)
        {
            Stop();
            SetEndpoint(ip, port);
            Start();
        }

        public void Stop()
        {
            if (!_isRunning) return;

            Logger.Write("Stopping server...");

            try
            {
                // Turn off the running bool
                _isRunning = false;

                // Stop the listener
                _listener.Close();

                // Stop the session timeout thread
                _timeoutThread.Join();

                // Close all open connections
                foreach (var connection in _connections.Values.Where(connection => connection != null)) connection.Close(false);
            }
            catch (Exception ex)
            {
                Logger.WriteError("Exception thrown in Server.Stop()", ex);
            }
        }

        #endregion

        #region Methods

        protected void CreateListener()
        {
            try
            {
                // If the listener isn't null, close before rebinding
                if (_listener != null) _listener.Close();

                // Bind to the listening port
                _listener = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                _listener.Bind(new IPEndPoint(_address, _port));
                _listener.Listen(10);
                _listener.BeginAccept(OnClientAccept, null);
                Logger.Write(string.Format("Server Ready - Listening for new connections {0}:{1}...", _address, _port));
            }
            catch (Exception ex)
            {
                Logger.WriteError("Exception thrown in Server.Start()", ex);
                throw;
            }
        }

        protected void SetEndpoint(string ip, int port)
        {
            // Load IP/Port settings
            if (string.IsNullOrWhiteSpace(ip) || string.Equals(ip, "any", StringComparison.OrdinalIgnoreCase)) _address = IPAddress.Any;
            else _address = IPAddress.Parse(ip);

            _port = port;
        }

        void OnClientAccept(IAsyncResult ar)
        {
            try
            {
                Socket clientSocket = _listener.EndAccept(ar);
                Interlocked.Increment(ref _connectionID);
                var connection = new Connection(_connectionID, clientSocket, new SmtpProcessor());
                connection.ConnectionClosed += connection_ConnectionClosed;
                _connections.Add(connection.ConnectionId, connection);
            }
            catch (ObjectDisposedException)
            {
                // This can occur when stopping the service.  Squash it, it only means the listener was stopped.
                return;
            }
            catch (ArgumentException)
            {
                // This can be thrown when updating settings and rebinding the listener.  It mainly means the IAsyncResult
                // wasn't generated by a BeginAccept event.
                return;
            }
            catch (Exception ex)
            {
                Logger.WriteError("Exception thrown in Server.OnClientAccept", ex);
            }
            finally
            {
                if (_isRunning)
                {
                    try
                    {
                        _listener.BeginAccept(OnClientAccept, null);
                    }
                    catch
                    {
                        // This normally happens when trying to rebind to a port that is taken
                    }
                }
            }
        }

        void SessionTimeoutWatcher()
        {
            int collectInterval = 5 * 60 - 1; // How often to collect garbage... every 5 mins
            int statusInterval = 20 * 60 - 1; // How often to print status... every 20 mins
            int collectCount = 0;
            int statusCount = 0;

            while (_isRunning)
            {
                try
                {
                    // Check if the program is up and ready to receive connections
                    if (!_isReady)
                    {
                        // If it is already trying to start, don't have it retry yet
                        if (!_isStarting) Start();
                    }
                    else
                    {
                        // Do garbage collection?
                        if (collectCount >= collectInterval)
                        {
                            // Get the number of current connections
                            var keys = new int[_connections.Count];
                            _connections.Keys.CopyTo(keys, 0);

                            // Loop through the connections
                            foreach (int key in keys)
                            {
                                // If they have been idle for too long, disconnect them
                                if (DateTime.Now < _connections[key].LastActivity.AddMinutes(20))
                                {
                                    Logger.Write("Session timeout, disconnecting", _connections[key].ConnectionId);
                                    _connections[key].Close();
                                }
                            }

                            GC.Collect();
                            collectCount = 0;
                        }
                        else collectCount++;

                        // Print status messages?
                        if (statusCount >= statusInterval)
                        {
                            double memusage = (double)Process.GetCurrentProcess().WorkingSet64 / 1024 / 1024;
                            Logger.Write(
                                string.Format(
                                    "Current status: {0} connections, {1}mb memory used",
                                    _connections.Count,
                                    memusage.ToString("0.#")));
                            statusCount = 0;
                        }
                        else statusCount++;
                    }
                }
                catch (Exception ex)
                {
                    Logger.WriteError("Exception occurred in Server.SessionTimeoutWatcher()", ex);
                }

                Thread.Sleep(1000);
            }
        }

        void Start()
        {
            Logger.Write("Starting server...");

            try
            {
                // Set it as starting
                _isRunning = true;
                _isStarting = true;

                // Start the thread to watch for inactive connections
                if (_timeoutThread == null)
                {
                    _timeoutThread = new Thread(SessionTimeoutWatcher);
                    _timeoutThread.Start();
                }

                // Create and start new listener socket
                CreateListener();

                // Set it as ready
                _isReady = true;
            }
            catch (Exception ex)
            {
                Logger.WriteError("Exception thrown in Server.Start()", ex);
                throw;
            }
            finally
            {
                // Done starting
                _isStarting = false;
            }
        }

        void connection_ConnectionClosed(object sender, EventArgs e)
        {
            var connection = sender as IConnection;
            if (connection == null) return;

            _connections.Remove(connection.ConnectionId);
        }

        #endregion

        public void Dispose()
        {
            Stop();
        }
    }
}